---
layout: post
title:  "기술 면접을 위한 정리"
date:   2018-08-19 23:50:00 +0900
categories: interview
---

## 예상 면접 질문

**[OOP]**

**1. 오버로딩과 오버라이딩**

오버라이딩은 상속과 연관이 있는데 상속 받은 클래스가 부모클래스에 있는 메소드를 재정의 하는 것이다.

오버로딩은 메소드 이름만 같고 매개변수를 다르게 하여 구현하는 것이다. 생성자 오버로딩과 연산자 오버로딩을 예로 들 수 있다.

**[Swift/ iOS]**

**1. 구조체와 클래스의 차이**

-구조체(Value 타입)

변수 할당 시 스택에 값 전체가 저장된다.

다른 변수에 할당될 때 전체 값이 복사된다.(copy by value)

힙을 안쓰며 따라서 레퍼런스 카운팅도 필요 없다

\- 클래스(Reference 타입)

하나의 Identity 변수가 Copy되어도 값이 하나를 향해 같은 값을 가진다.

레퍼런스의 의도하지 않은 공유로 인한 문제를 조심해야한다.

****

**2. 참조 순환이 일어나는 조건에 대해서 설명해 보세요.**

\- 객체간의 관계 의존성/ 클로저에서 내부 프로퍼티 사용/ 델리게이트

**3. 뷰 컨트롤러 라이프 사이클**

****

**4. 앱 라이프 사이클**

앱 실행 -> 메인 스레드 실행 -> UIApplicationMain 함수는 핵심 객체를 설정하고, 앱 실행을 준비합니다. ->

**5. 델리게이트 패턴, 싱글튼 패턴**

****

**6. 백그라운드/포그라운드 상태에서 고려 해야할 작업**

****

**7. String Interning이란?**

NSString 객체를 선언하면 내부적으로 인터닝 방법을 사용한다. 인터닝이란 동일한 불변 스트링 리터럴에 대해서 오직 하나의 인스턴스만 힙 공간에 할당하는 것이다. 이 공간을 string pool이라고 부르는데, 이 공간에 할당되는 스트링 리터럴은 모두 다르며, 스트링 풀에 존재하는 변수를 선언하면, 스트링 풀의 인스턴스를 가리킨다.

**8. 스위프트 4.1에서 달라진 점은?**

flatMap이 compactMap으로 바뀌었고, Equtable과 Hashable을 채택하면 default 구현이 되어있다. 재귀적인 프로토콜 허용.

**9. 오토레이아웃에 대해서**

**10. GCD를 쓰는 것과 NSThread 쓰는 것의 차이**

GCD는 멀티 코어 프로세서를 위한 스레드 프로그래밍을 OS에서 자동 관리/분배 해 주는 C 라이브러리다. 즉 생성한 스레드를 어떻게 멀티코어 프로세서에 분산 시킬 것인가에 대한 고민을 없애 주었다.

**[운영체제]**

**1. CPU 가상화란 무엇이고 이로 인해 생길 수 있는 문제점과 해결책**

하나 또는 소수의 CPU 집합을 무한 개의 CPU가 존재하는 것처럼 변환하여 동시에 많은 수의 프로그램을 실행시키는 것

성능저하

제어문제: 제한적 직접 실행(커널과 사용자 모드)

파일 시스템 접근, 프로세스 생성 및 제거, 다른 프로세스와의 통신 및 메모리 할당은 커널 모드에서 시스템 콜을 통해 실행 가능하다.

시스템 콜을 실행하기 위해 프로그램은 trap 특수 명령어를 실행하고, 이 명령어는 커널 안으로 분기하는 동시에 특권 수준을 커널 모드로 상향 조정한다.

**2. 프로세스의 주소 공간에 대해 설명해 주세요.**

코드(Text): 프로그램 코드 (실행 명령어)

데이터: 고정 값이 정해진 전역 변수, static 변수

심벌(BSS-Block Stated Symbol): 초기화 되지 않은 전역/static 변수. 실행되기 전에 0으로 초기화한다.

힙: 동적으로 할당되는 메모리. (C: malloc. C++/Java: new, Swift: 클래스 객체 인스턴스는 힙 영역에 만들어지며, 해당 힙 메모리 주소를 스택 영역에 할당한 포인터로 참조해서 접근한다.)

스택: 로컬 변수, 매개변수, 리턴 주소 등

**3. 프로세스 생성 과정을 설명해 보세요.**

1. 프로그램은 디스크 또는 플래시 기반 SSD에 특정 실행 파일 형식으로 존재한다.
2. 운영체제는 디스크의 해당 바이트를 읽어 코드와 정적 데이터를 주소 공간에 로드한다.
3. 일정량의 메모리가 메모리가 프로그램의 런타임 스택 용도로 할당된다.
4. 힙을 위한 공간을 할당한다.
5. 입출력과 관계된 초기화 작업을 수행한다.
6. 프로그램의 엔트리 포인트인 main() 루틴으로 분기하여 새로생성된 프로세스에 cpu를 할당하고 프로그램이 실행된다.

**4. 스레드에 대해서 설명해 주세요.**

프로세스의 독립적인 실행 흐름으로 스택을 제외한 주소 공간을 공유하고 있다.

고유한 스택 데이터들은 thread local storage에 저장된다.

하나의 프로세스에서 병렬적으로 여러 개의 작업을 처리하기 위해서는 각 작업을 스레드화 하여 멀티스레딩이 가능하게 해야한다.

**5. 메모리 가상화 기법에 대해서 설명하세요.**

사용자 프로그램이 생성하는 모든 주소는 가상주소이다. 운영체제는 각 프로세스가 자신만의 커다란 전용 메모리를 가진다는 환상을 제공한다. 하드웨어로부터 도움을 얻어 가상 주소를 실제 물리 주소로 변환하고 원하는 물리메모리의 주소를 얻어낼 수 있다.

이는 프로그래머가 이 변수를 어디에 저장할지에 대해서 고민하지 않게 만든다.

프로세스들의 주소공간 크기가 한정된 메모리보다 크기 때문에 메모리를 공유함으로써 문제를 해결한다. 각 프로세스는 자신만의 가상 주소를 가지고 있고, 운영체제는 실제 물리 메모리로 매핑한다.

**6. 메모리 관리 전략에 대해서 설명하세요.**

-스와핑: CPU를 사용하고 있지 않은 ready나 waiting 상태의 프로세스(프로세스 상태에 의존적이다)를 디스크에 저장해두는 기법이다. 디스크에 저장할 때는 프로그램 상태가 아닌 프로세스 상태이다.

cpu가 다음 실행할 프로세스를 정할 때 디스패치를 호출하고 디스패처는 래디큐에 있는 프로세스가 메모리에 올라와 있는지 확인합니다. 만약 없으면 스왑인 작업을 해야 하는데, 정적 바인딩된 프로세스인 경우는 원래 기존 주소에 스왑인 되고 동적 바인딩 된 프로세스는 메모리의 빈 공간 어디라도 올 수 있습니다.

하지만 메모리에 올라와 있는게 아니기 때문에 스왑 인 할때 주소 바인딩을 해줘야 한다. (런타임에 동적으로 주소 바인딩)

\- 요구 페이징: 스왑 단위가 페이지.

**6-1. 세그멘티이션 기법에 대해서 설명해 보세요.**

주소공간을 가변 크기의 논리적인 세그먼트로 나누며 각 세그먼트마다 베이스와 바운드 쌍이 존재한다. 여기서 세그먼트는 코드, 스택, 힙을 의미하며 더 작은 크기로 분할하기도 한다.



**6-2. 페이징에 대해서 자세히 설명해 보세요.**

주소 공간을 고정 크기의 페이지로 나눈것. 물리메모리에서는 페이지 프레임이라 부른다. 주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위해 페이지 테이블이라는 자료구조를 유지한다. 페이지 테이블은 프로세스 마다 존재하며 매우 크고 페이지의 물리 메모리 주소를 알기위해 메모리에 접근 하는 것은 속도를 낮춘다.

속도를 낮추기 위해서는 TLB(translation-lookaside buffer) 즉 변환색인버퍼를 사용한다. MMU의 일부로 주소-변환 캐시이다.

페이지 테이블의 크기가 매우 큰데 스와핑을 통해 디스크에 저장한다.

**6-3. 페이지 교체 알고리즘**

페이지를 스왑인 했는데 빈 메모리가 없다면?

페이지를 교체한다. FIFO LRU

****

**6-4. 빈 공간 관리**

malloc()과 free()에서처럼 사용자 수준 메모리 할당 라이브러리에서, 그리고 세그멘테이션으로 물리 메모리를 관리하는 운영체제에서 빈공간 관리가 까다로워 진다.

**7. CPU 스케줄링에 대해 아는대로 설명해 보세요.**

****

**9. 프로세스 동기화를 위한 기법으로 무엇이 있는가?**

락과 세마포어.

공유 자원을 보호하기 위한 자물쇠가 있고 스레드에서 공유자원을 사용하려면 자물쇠를 획득해야한다.

뮤택스라고도 부른다.

**8. 교착상태 필요 조건에는 무엇이 있는가?**

\- 상호배제: 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장한다

\- 점유 대기: 쓰레드가 자신에게 할당된 자원을 점유한 채로 다른 자원을 대기한다.

원자적으로 모든 락을 단번에 획득하도록 하면 예방할 수 있다.

\- 비 선점: 락을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없다.

\- 순환 대기: 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 락을갖고 있는 쓰레드들의 순환 고리가 있다.

예방과 회피

두 개의 서로 다른 스레드에서 서로 상대방이 필요로 하는 자원에 대한 락을 가지고 있는 경우에 일어난다.

****

**[자료구조/ 알고리즘]**

**1. List**

**1-1.ArrayList와 LinkedList의 차이는?**

두 자료구조의 차이점은 원소 삽입 삭제/ 그리고 원소 검색에 차이가 나타납니다.

ArrayList는 물리적 저장 위치와 논리적 저장 위치가 같기 때문에 원소의 인덱스 값만 안다면 O(1) 시간 복잡도로 원소 접근이 가능합니다. 하지만 삽입 삭제의 경우 해당 원소의 인덱스보다 큰 인덱스의 원소들을 1씩 Shift 해야 하기 때문에 시간 복잡도 O(n)이 됩니다.

**1-2. 링크드 리스트를 구현해 보세요**

단일/ 이중/ 원형(x) 중 어떤걸 구현할까요? 스위프트로 구현해도 되나요?

**1-3. 링크드 리스트를 어디에 사용하나요?**

\- 큐를 구현할 때 사용합니다. 큐는 선입선출인데, head와 tail이 있는 링크드리스트를 이용하면 시간복잡도 O(1)로 구현 가능합니다.

**2. Stack이란?**

후입선출 자료구조로 마지막에 삽입된 원소가 삭제 시 가장 먼저 삭제됩니다. 스택은 여러 개의 서브 태스크로 나뉘는 태스크를 관리하는 데 유용하게 쓰이는 자료구조이고 스택을 사용하는 대표적인 예는 서브루틴에서 사용할 반환주소, 매개 변수, 지역 변수 등을 추적하는 것을 들 수 있습니다. 또 다른 예로는 프로그래밍 언어를 파싱할 때 토큰을 추적하는 것을 들 수 있습니다.

**2-2. Stack을 무엇으로 구현할 것인가?**

스택을 구현하는 방법으로는 동적 배열과 링크드 리스트가 있습니다. 링크드 리스트는 각 노드마다 메모리를 동적으로 할당해야 하기 때문에 그에 따른 오버헤드가 발생합니다. 만약 적절한 동적 배열 크기를 지정하여 배열 크기를 새로 조절하지 않아도 된다면 동적 배열이 더 성능이 좋을 것이라 생각하기 때문에 동적배열을 이용하여 구현할 것입니다.

**3. 트리 **

**3-1. 이진 검색 트리에 대해서 설명해 주세요.**

트리의 종류중 하나로 자식 노드가 없거나 최대 두개를 가진 트리입니다. 두개의 노드에는 왼쪽 자식과 오른쪽 자식이 있는데 왼쪽 자식 노드는 부모노드보다 값이 작고 오른쪽 자식 노드는 부모 노드보다 값이 큽니다.

이진 검색 트리의 장점은 룩업 연산을 빠르고 간단하게 처리할 수 있다는 점 입니다.

하지만 균형된 트리가 아닌, 자식이 하나만 있는 이진 검색 트리의 경우는 검색 시 링크드 리스트와 성능이 같아집니다.

따라서 균형된 트리를 만들기 위해 레드 블랙 트리나 AVL 트리 같은 자료구조를 사용합니다.

**3-2. 이진 검색 트리를 구현해보세요.**

재귀를 생각하자!

**3-3. 힙에 대해서 설명해 주세요.**

****

**4. 그래프**

그래는 정점과 간선들의 집합입니다. 트리는 그래프의 한 종류이며, 트리와 그래프의 차이점은 트리는 한 노드에 부모노드 하나만 있지만 그래프는 한 노드에 부모노드가 여러개 있을 수 있기 때문에 사이클이 만들어 질 수 있다는 것입니다. 그래프는 인접 리스트와 인접 행렬로 구현 가능합니다.

**4-1. **

큐를 이용하여 BFS 즉 너비 우선 탐색을 구현할 수 있다.

****

**5. 정렬**

선택정렬: 첫번째 원소를 선택한 뒤 나머지 배열에서 가장 작은 값을 찾아 첫번째 원소와 맞바꾼다. 두번째 원소에서 마지막에 이르기까지 같은 작업을 반복한다. 시간복잡도는 O(n제곱)이다. 데이터 원소를 움직이는 게 비교 작업에 비해 비싼 경우에는 선택 정렬이 다른 알고리즘 보다 빠를 수도 있다.

삽입정렬: 삽입정렬은 최선의 경우, 즉 리스트가 이미 정렬돼 있을 때 O(n)이다. 이미 정렬된 리스트에 새 원소를 추가할 때는 삽입 정렬이 매우 효율적이다. 최악의 경우에는 O(n제곱)이다.

퀵소트: 보통 시간 복잡도가 O(nlogn) 최악은 o(n제곱)

최고 > 피벗 값이 중간 값일 때

최악 > 피벗 값이 최소 값/ 최대 값일 때

머지소트: 최악, 최고, 평균 모드 O(nlogn) 단 O(n) 수준의 메모리가 추가로 필요하다.

****

**[네트워크]**

**1. 웹 브라우저에 주소를 입력하고 화면이 뜨기까지의 과정**

사용자가 주소를 입력하면 호스트 명을 추출합니다. 호스트 명은 DNS를 통해 IP로 변환 됩니다.IP와 포트번호를 이용해 웹 서버와 TCP 커넥션을 맺습니다. 웹브라우저는 서버에 HTTP 요청을 보내고 서버는 웹 브라우저에 HTTP응답을 돌려준다. 커넥션이 닫히면 웹 브라우저는 문서를 보여준다.

**2. HTTPS**

http와 거의 같지만 HTTP의 커넥션의 양 끝단에서 암호화하기 위해 넷스케이프에서 개발한 보안 소켓 계층(SSL)을 사용한다.

**3. Http2**

Http1.0의 성능을 보완하고자 만든 것이다.

헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖추고 있다.

**TCP/ UDP 프로토콜**

**브로드캐스트 (여러개의 장치를 제어)**

**[아키텍처 패턴]**

**1. MVC**

**2. MVVM**

****
